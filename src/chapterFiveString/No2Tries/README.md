这里学习的算法在一般应用场景中（甚至对于巨型的符号表）都能取得以下的性能。
查找命中所需的时间与被查找的键的长度成正比。
查找未命中只需检查若干个字符。

单词查找树。

命题f。单词查找树的链表结构和键的插入或删除顺序无关。对于任意给定的一组键，其单词查找树都是唯一的。

证明。由数学归纳法，很容易通过子单词查找树证明这个结论。


命题G。在单词查找树中查找一个键或者插入一个键时。访问数组的次数最多为键的长度加1。

证明。由代码可知put()和get()方法的递归实现都带有一个参数d，它们的初始值为0，每次调用时都会加1，当长度,等于键的长度时递归调用停止。

命题H。字母表的大小为R，在一颗由n个随机键构造的单词查找树中，未命中查找，平均所需检查的节点数量为~logrN。

简略证明。所有的n个键都与一个随机的查找键的前t个字符中至少有一个字符不同的概率为(1-R-t)N，用一减去它即可得到单词查找树中至少有一个键和被查找键的前t个字符都匹配的概率。也就是说查找操作至少需要比较t个字符的概率。

命题I。一颗单词查找树中的链接总数在RN到RNw之间，其中w为键的平均长度。

证明。在单词查找树中，每个键都有一个对应的结点保存着它关联的值，同时每个结点也含有R条链接，因此链接总数至少有RN条。如果所有的键的首字母均不相同，那么每个键中的每个字母都有一个对应的结点，因此链接总数应该等于R乘以所有键中的字符总数，即RNw。

命题J。由n个平均长度为w的字符串构造的三向单词查找树中的链接总数在3N到3Nw之间。

证明同命题I。

命题k。在一颗有n个随机字符串构造的三向单词查找树中，查找未命中平均需要比较字符lnN次。除lnN次外，一次插入或命中的查找会比较一次被查找的键中的每个字符。

证明。由代码，我们马上可以得到插入和查找命中的成本，查找未命中的成本的证明和命题H的简略证明相同，假设在查找路径上除了常数个节点（高层的几个）之外的其他所有节点均为由R个字符值随机构造的2叉查找树且树的平均路径长度为lnR。

命题L。由n个随机字符串构造的根节点进行了Rt向分支，且不含有外部单向分支的三项单词查找树中，一次插入或查查找操作平均需要进行约lnN-tlnR次字符比较。

证明。这些粗略的估计也可以由命题k的证明得到。假设在查找路径上，除了常数个节点（高层的几个）之外的其他所有结点均为由R个字符值组成的二叉查找树，因此需要将时间成本乘以lnR。