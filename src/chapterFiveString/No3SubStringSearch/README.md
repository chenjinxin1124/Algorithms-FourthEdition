子字符串查找有一个简单而广泛的暴力方法。虽然他在最坏情况下的运行时间与mn成正比，但是在处理许多应用程序中的字符串时，除了一些变态的情况之外，它的实际运行时间一般与m加n产生，另外它很好的利用了大多数计算机系统中标准的结构特性，因此即使是更加巧妙的算法，也很难超越它经过优化后的版本的性能。

命题m。在最坏的情况下，暴力子字符串查找算法在长度为n的文本中查找长度为m的模式需要nm次字符比较。

证明。一种最坏的情况是文本和模式都是一连串的a接一个b，那么，对于n-m+1个可能的匹配位置，模式中的所有字符都需要和文本比对。总成本为m(n-m+1)。一般来说m远小远n，因此总成本为nm。

命题n。对于长度为m的模式字符串和长度n的文本，kMP字符串查找算法访问的字符不会超过n+m个。

证明。由代码可以马上得到，在计算dfa[][]时，算法会访问模式字符串中的每个字符一次，在Search()方法中会访问文本中的每个字符(最坏情况下)一次。

命题o。在一般情况下，对于长度为n的文本和长度为m的模式字符串使用了bm的子符串查找算法，通过启发式处理，不匹配的字符需要n/m次字符比较。

讨论。我们可以用各种随机字符串模型证明该结论，但这些模型一般都不太可能在实际情况中出现，因此这里省略了
证明的细节。在许多实际应用场景中，模式字符串中，仅含有字母表中的若干字符是很常见的，因此几乎所有的比较都会使算法跳过m个字符，这样就得到了以上结论。

命题p。使用蒙特卡罗算法的RK子字符串查找算法的运行时间是线性级别的，且出错的概率极小，使用拉斯维加斯算法的RK子符串查找算法能够保证正确性且性能极其接近线性级别。

讨论。因为我们不需要实际创建一张散列表，使用非常大的q几乎不可能发生散列冲突。理论上来说，文本中的某个子符串，可能会在与模式不匹配的情况下产生产生散列冲突，但在实际应用中使用该算法寻找匹配是可靠的。