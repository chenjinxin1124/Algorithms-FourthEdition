对于许多排序应用，决定顺序的键都是字符串。这里学习利用字符串的特殊性质，将字符串键排序的方法。

第1类方法会从左到右检查键中的字符串，这种方法一般被称为低位优先的字符串排序。LSD

命题A。键索引计数法排序N个键为0到R-1之间的整数的元素需要访问数组，11N+4R+1次。

证明。根据代码可得初始化数组会访问数组N+R+1次，在第1次循环中n个元素均会使计数器的值加1(访问数组2N次);第2次循环会进行R次加法(访问数组2R次);第3次循环会使计数器的值增加n次，并移动n次数据(访问数组3N次);第4次循环会移动数据n次(访问数组2N次);所有的移动操作都维护了等键元素的相对顺序。

命题B。低位优先的字符串排序算法能够稳定的将定长字符串排序。

证明。该命题完全依赖于键索引计数法的实现是稳定的，这种稳定性已经在命题a中指出了。在将他们的最后i个字符作为键（用稳定的方式）进行排序之后，可以知道，任意两个键在数组中的顺序都是正确的（只考虑这些字符）。要么因为它的倒数第i个字符不同，所以排序方法已经将它们的顺序摆放正确，要么它们的倒数第i个字符相同，所以由于排序的稳定性它们仍然有序（由归纳法可知，对于I-1这一点仍然正确）。

命题B(续）。对于基于R个字符的字母表的n个，以长为w的字符串为键的元素，低位优先的字符串排序需要访问~7wn+3wr次数组使用的额外空间与n+r成正比。

证明。该方法等价于进行，w轮键索引计数法，但是aux[]只会被初始化一次，根据前面的代码和命题a，即可得到算法访问数组和使用空间的总数。


第2类方法会从左到右检查键中的字符，首先查看的是最高位的字符，这些方法通常称为高位优先的字符串排序。MSD

命题c。要将基于大小为R的字母表的n个字符串排序，高位有限的字符串排序算法平均需要检查NlogRN个字符。

简略证明。我们希望子数组的大小几乎都是相同的，因此递归关系cn=rcn/r+n可以近似的描述算法的性能，并得到命题所述的结果，它也是第2章中快速排序性能证明的一般化证明，另一方面这种描述并不完全准确，因为n/r并不一定能够得到整数,子数组的大小相同也仅是平均而言（而且在现实中见的长度是有限的），这些因素对高位优先的字符串排序算法的影响比标准快速排序算法的影响小，因此算法运行时间中的最大项就是这个递推关系的答案，这个问题的详细证明是算法分析中的经典例子。最早由knuth完成于20世纪70年代早期。

命题D。要将基于大小为R的字母表的n个字符串排序，高位优先的字符串排序算法访问数组的次数在8n+3R到7wr+3wr之间，其中w是字符串的平均长度。

证明有代码命题a和命题B可得，在最好情况下，高位优先的排序算法只需遍历数组一轮，而在最坏情况下，它和低位优先的字符串排序算法的性能类似。

命题D（续）。要将基于大小为r的字母表的n个字符串排序，最坏情况下，高位优先的字符串排序算法所需的空间，y与r乘以最长的字符串的长度之积成正比(再加上n).

证明count[]数组必须在sort()中创建，因此空间需求的总量与r和递归的深度之积成正比（再加上辅助数组的大小n）。准确地说，递归的深度即最长字符串的长度也就是两个或多个被排序的字符串的公共前缀的长度。

三向字符串快速排序。

命题E。要将含有n个随机字符串的数组排序，三向字符串快速排序平均需要比较字~2nlnN次。

证明。我们可以用两种方式来理解这个结论，首先将这个方法看作在快速排序中用首字母切分并（递归地）调用相同的方法将子数组排序，那么它所需的操作数量和普通的快速排序相同，就一点也不奇怪了。但这只是比较单个字符所需的操作，而非比较整个键所需的次数。其次，我可以将这个方法看作，用快速排序代替了键索引计数法，根据命题c我们预计的运行时间为n log rn与2lnN的积，这是因为快速排序需要2RlnR步来将R个字符排序，而对于相同的字符串，高位优先的字符串排序算法只需R步.